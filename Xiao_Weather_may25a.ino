#include "arduino_secrets.h"
/*
  Sketch to interogate the DHT11, display the results and send to Arduino IOT
*/

/*
  Sketch generated by the Arduino IoT Cloud Thing "Xiao Weather"
  https://create.arduino.cc/cloud/things/8b2c66c8-a852-4a0b-8370-59ef00bcc282

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String xiao_19_comfort;
  float xiao_19_depoint;
  float xiao_19_heatindex;
  float xiao_19_humidity;
  float xiao_19_temperature;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

// ESP32C3 #23 Board

// Libraries

#include "thingProperties.h"                      // Arduino IOT library: Written by Ardiuno
#include "DHTesp.h"                               // Click here to get the library: http://librarymanager/All#DHTesp
#include <Wire.h>                                 // for connecting to the DHT11: https://reference.arduino.cc/reference/en/language/functions/communication/wire/
#include <Adafruit_GFX.h>                         // graphics library for the OLED: https://github.com/adafruit/Adafruit-GFX-Library
#include <Adafruit_SSD1306.h>                     // OLED library: https://github.com/adafruit/Adafruit_SSD1306

// definitions

#define SCREEN_WIDTH 128                          // OLED display width, in pixels
#define SCREEN_HEIGHT 64                          // OLED display height, in pixels
#define SMALL 1                                   // OLED library text sizes as an integer 
#define MEDIUM 2
#define LARGE 3
#define dhtPin A2                                 // pin for DHT
#define BAUD 9600                                 // serial monitor BAUD rate

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)

#define OLED_RESET     -1                         // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3D                       // See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Objects

DHTesp dht;                                       // Initialize the sensor
ComfortState cf;                                  // ComfortState is returned by the DHT11 sensor

// Constants

int const delay_time = 3000;                      // 3 second delay
int const long_delay = 6000;                      // 6 sceond delay
String const copyright = "(C)SGF2023";            // string to hold copyright information
String const email = "sgfpcb@gmail.com";          // string to hold email address
bool Redraw1 = true;                              // graph variables
bool Redraw3 = true;
float lowTempVal = 0;                             // low scale temperature
float highTempVal = 40;                           // high scale temperature
float lowHumVal = 0;                              // low humidity scale
float highHumVal = 100;                           // high humidity scale

// ***************************************************************************
// function to get data from DHT11
//
// Reading temperature for humidity takes about 250 milliseconds!
// Sensor readings may also be up to 2 seconds 'old' (it's a very slow sensor)
//
// ***************************************************************************
bool getTemperature() {

  TempAndHumidity newValues = dht.getTempAndHumidity();

  if (dht.getStatus() != 0) {                     // Check if any reads failed and exit early (to try again).
    Serial.println("DHT11 error status: " + String(dht.getStatusString()));

    display.clearDisplay();
    displayPrint(MEDIUM, 0, 0, "DHT11 ERROR");
    displayPrint(MEDIUM, 0, 20, String(dht.getStatusString()));

    delay(delay_time);

    return false;
  }

  // call functions and return results from DHT11

  float heatindex = dht.computeHeatIndex(newValues.temperature, newValues.humidity);
  float dewpoint = dht.computeDewPoint(newValues.temperature, newValues.humidity);
  float cr = dht.getComfortRatio(cf, newValues.temperature, newValues.humidity);

  // get comfortStatus from DHT11 and use Select Case function to determine String

  String comfortStatus;
  switch (cf) {
    case Comfort_OK:
      comfortStatus = "OK";
      break;
    case Comfort_TooHot:
      comfortStatus = "Too Hot";
      break;
    case Comfort_TooCold:
      comfortStatus = "Too Cold";
      break;
    case Comfort_TooDry:
      comfortStatus = "Too Dry";
      break;
    case Comfort_TooHumid:
      comfortStatus = "Too Humid";
      break;
    case Comfort_HotAndHumid:
      comfortStatus = "Hot/Humid";
      break;
    case Comfort_HotAndDry:
      comfortStatus = "Hot & Dry";
      break;
    case Comfort_ColdAndHumid:
      comfortStatus = "Cold/Humid";
      break;
    case Comfort_ColdAndDry:
      comfortStatus = "Cold/Dry";
      break;
    default:
      comfortStatus = "Unknown:";
      break;
  };

  // print results to Serial Monitor

  Serial.print(" TMP:" + String(newValues.temperature));
  Serial.print(" HUM:" + String(newValues.humidity));
  Serial.print(" HIX:" + String(heatindex));
  Serial.print(" DEW:" + String(dewpoint));
  Serial.println(" " + comfortStatus);

  // store results in Arduino IOT variables

  xiao_19_temperature = newValues.temperature;
  xiao_19_humidity = newValues.humidity;
  xiao_19_comfort = comfortStatus;
  xiao_19_depoint = dewpoint;
  xiao_19_heatindex = heatindex;

  return true;

} // bool getTemperature()

// *****************************************************
// * Set up function
// *****************************************************

void setup() {

  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {      // Address 0x3D for 128x64
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);                                            // loop forever
  }

  delay(2000);
  display.clearDisplay();
  display.setTextSize(SMALL);
  display.setTextColor(WHITE);
  display.display();

  // set up DHT11 object
  dht.setup(dhtPin, DHTesp::DHT11);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(MEDIUM);
  ArduinoCloud.printDebugInfo();

  Serial.println("DHT Xiao ESP32 example with tasks");

  Wire.begin();                          // to communicate with the DHT11

  //display Welcome screen
  display.clearDisplay();
  displayPrint(MEDIUM, 0, 0,  "  Welcome ");
  displayPrint(MEDIUM, 0, 20, "ArduinoIOT");
  displayPrint(SMALL, 0, 45, "Code by Steve Fuller");
  displayPrint(SMALL, 10, 57, "sgfpcb@gmail.com");

  delay(long_delay);                     // double display time for welcome screen

  Serial.println("Ready");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());

  // display WiFi connection message
  display.clearDisplay();
  displayPrint(MEDIUM, 0, 0, "CONNECTED:");
  String ssid_text = SSID;

  // change text size dependent on SSID length
  int ssid_len = ssid_text.length();
  if (ssid_len > 10) {

    displayPrint(SMALL, 0, 30, SSID);

  } else {

    displayPrint(MEDIUM, 0, 30, SSID);

  }

  delay(delay_time);

} // void setup)()

// ************************************************************
// * Main Program Loop
// ************************************************************

void loop() {

  getTemperature();                       // get data from DHT11

  ArduinoCloud.update();                  // update the Arduino IOT

  delay(delay_time);

  // Temperature data is displayed from getTemperature() function
  // display all data at once
  display.clearDisplay();
  displayPrint(SMALL, 13, 5, "TEMP and HUMIDITY");
  drawHeaderLine();

  displayPrint(SMALL, 0, 21, "TEMPERATURE " + String(xiao_19_temperature) + "C");
  displayPrint(SMALL, 0, 33, "HUMIDITY    " + String(xiao_19_humidity) + "%");
  displayPrint(SMALL, 0, 45, "DEWPOINT    " + String(xiao_19_depoint) + "C");
  displayPrint(SMALL, 0, 57, "Comfort     " + String(xiao_19_comfort));

  // The main display is on for longer
  delay(long_delay);

  // display data one page at a time
  // **** TEMPERATURE DISPLAY ****
  display.clearDisplay();
  displayPrint(MEDIUM, 42, 0, "TEMP");
  drawHeaderLine();
  displayPrint(LARGE, 10, 26, String(xiao_19_temperature) + "C");
  showCopyright();

  delay(delay_time);

  // display data one page at a time
  // **** HUMIDITY DISPLAY *****
  display.clearDisplay();
  displayPrint(MEDIUM, 18, 0, "HUMIDITY");
  drawHeaderLine();
  displayPrint(LARGE, 10, 26, String(xiao_19_humidity) + "%");
  showCopyright();

  delay(delay_time);

  // draw a graph for temperature and humidity
  // **** GRAPH DISPLAY ****
  display.clearDisplay();
  displayPrint(MEDIUM, 16, 0, String(xiao_19_temperature, 0) + "C");
  displayPrint(MEDIUM, 70, 0, String(xiao_19_humidity, 0) + "%");

  drawHeaderLine();

  //                                          X,   Y,   W,  H, LOW VALUE,  HIGH VAL,    INC, DIG
  DrawBarChartV(display, xiao_19_temperature, 15,  60, 25, 35, lowTempVal, highTempVal, 10, 0, "Temp", Redraw1);
  DrawBarChartV(display, xiao_19_humidity,    70,  60, 25, 35, lowHumVal,  highHumVal, 25, 0, "Hum", Redraw1);

  delay(long_delay);

  display.clearDisplay();
  
  displayPrint(MEDIUM, 16, 0, "TEMP:" + String(xiao_19_temperature, 0) + "C");
  
  //                                     X,  Y,  R,   Low,       High,        inc, sweep, label
  DrawDial(display, xiao_19_temperature, 65, 52, 25, lowTempVal, highTempVal, 5,   0, 200, "Temp", Redraw3);
  
  delay(long_delay);
  
  display.clearDisplay();

  displayPrint(MEDIUM, 24, 0, "HUM:" + String(xiao_19_humidity, 0) + "%");
  
  DrawDial(display, xiao_19_humidity, 65, 52, 25, lowHumVal, highHumVal, 25, 0, 200, "Hum", Redraw3);
  
  delay(long_delay);

  // display data one page at a time
  // **** COMFORT DISPLAY ****
  display.clearDisplay();
  displayPrint(MEDIUM, 0, 0, "  COMFORT");
  drawHeaderLine();

  // *************************************************
  // Set the position of the comfort text (central)
  // depending on its length and set its size to fit
  // *************************************************
  display.setTextSize(LARGE);

  int txtlen = xiao_19_comfort.length();   // the text's length
  int x_posn = 0;                          // initial x position
  int y_posn = 0;                          // initial y position
  int textSize = SMALL;                    // set text size

  switch (txtlen) {
    case 2: // Ok - centered
      x_posn = 50;
      y_posn = 25;
      textSize = LARGE;
      break;
    case 7: // Too Hot
      x_posn = 20;
      y_posn = 25;
      textSize = LARGE;
      break;
    case 8: // Too Cold - centered
      x_posn = 15;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    case 9: // Too Humid - centered
      x_posn = 10;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    case 10: //  Cold/Humid 
      x_posn = 0;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    case 11: // Hot & Humid
      x_posn = 0;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    case 12: // Cold & Humid
      x_posn = 0;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    default:
      x_posn = 0;
      y_posn = 30;
      textSize = SMALL;
      break;
  }; // switch(txtlen)

  displayPrint(textSize, x_posn, y_posn, xiao_19_comfort);
  showEmail();

} // void loop()


void showCopyright() {                      // display the copyright text on last line

  displayPrint(SMALL, 35, 57, copyright);

}

void showEmail() {                          // display the email address on the last line

  displayPrint(SMALL, 17, 55, email);

}

void drawHeaderLine() {                     // display a line underneath the header

  display.drawLine(5, 16, 120, 16, WHITE);

}

// *********************************************
// * function to print to the display
// *********************************************
void displayPrint(int txtSize, int x_posn, int y_posn, String txt) {

  display.setTextSize(txtSize);
  display.setCursor(x_posn, y_posn);
  display.print(txt);
  display.display();

}

void DrawBarChartV(Adafruit_SSD1306 &d, double curval, double x, double y, double w, double h, double loval, double hival, double inc, double dig, String label, bool &Redraw)
{
  double stepval, my, level, i, data;

  if (Redraw) {
    //Redraw = false;
    //d.fillRect(0, 0,  127, 14, SSD1306_WHITE);
    //d.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
    d.setTextSize(SMALL);
    //d.setCursor(x, y);
    //d.println(label);
    // step val basically scales the hival and low val to the height
    // deducting a small value to eliminate round off errors
    // this val may need to be adjusted
    stepval = ( inc) * (double (h) / (double (hival - loval))) - .001;
    for (i = 0; i <= h; i += stepval) {
      my =  y - h + i;
      d.drawFastHLine(x + w + 1, my,  5, SSD1306_WHITE);
      // draw lables
      d.setTextSize(SMALL);
      d.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
      d.setCursor(x + w + 12, my - 3 );
      data = hival - ( i * (inc / stepval));
      d.print(data, dig);
    }
  }
  // compute level of bar graph that is scaled to the  height and the hi and low vals
  // this is needed to accompdate for +/- range
  level = (h * (((curval - loval) / (hival - loval))));
  // draw the bar graph
  // write a upper and lower bar to minimize flicker cause by blanking out bar and redraw on update
  d.drawRect(x, y - h, w, h, SSD1306_WHITE);
  d.fillRect(x, y - h, w, h - level,  SSD1306_BLACK);
  d.drawRect(x, y - h, w, h, SSD1306_WHITE);
  d.fillRect(x, y - level, w,  level, SSD1306_WHITE);
  // up until now print sends data to a video buffer NOT the screen
  // this call sends the data to the screen
  d.display();

}

void DrawDial(Adafruit_SSD1306 &d, double curval, int cx, int cy, int r, double loval, double hival, double inc, double dig, double sa, String label, bool &Redraw) {

  double ix, iy, ox, oy, tx, ty, lx, rx, ly, ry, i, Offset, stepval, data, angle;
  double degtorad = .0174532778;
  static double px = cx, py = cy, pix = cx, piy = cy, plx = cx, ply = cy, prx = cx, pry = cy;

  if (Redraw) {
    //Redraw = false;
    // draw the dial only one time--this will minimize flicker
    //d.fillRect(0, 0,  127, 16, SSD1306_WHITE);
    //d.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
    d.setTextSize(1);
    //d.setCursor(2, 4);
    //d.println(label);
    // center the scale about the vertical axis--and use this to offset the needle, and scale text
    Offset = (270 +  sa / 2) * degtorad;
    // find hte scale step value based on the hival low val and the scale sweep angle
    // deducting a small value to eliminate round off errors
    // this val may need to be adjusted
    stepval = ( inc) * (double (sa) / (double (hival - loval))) + .00;
    // draw the scale and numbers
    // note draw this each time to repaint where the needle was
    for (i = 0; i <= sa; i += stepval) {
      angle = ( i  * degtorad);
      angle = Offset - angle ;
      ox =  (r - 2) * cos(angle) + cx;
      oy =  (r - 2) * sin(angle) + cy;
      ix =  (r - 10) * cos(angle) + cx;
      iy =  (r - 10) * sin(angle) + cy;
      tx =  (r + 10) * cos(angle) + cx + 8;
      ty =  (r + 10) * sin(angle) + cy;
      d.drawLine(ox, oy, ix, iy, SSD1306_WHITE);
      d.setTextSize(1);
      d.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
      d.setCursor(tx - 10, ty );
      data = hival - ( i * (inc / stepval)) ;
      d.println(data, dig);
    }
    for (i = 0; i <= sa; i ++) {
      angle = ( i  * degtorad);
      angle = Offset - angle ;
      ox =  (r - 2) * cos(angle) + cx;
      oy =  (r - 2) * sin(angle) + cy;
      d.drawPixel(ox, oy, SSD1306_WHITE);
    }
  }
  // compute and draw the needle
  angle = (sa * (1 - (((curval - loval) / (hival - loval)))));
  angle = angle * degtorad;
  angle = Offset - angle  ;
  ix =  (r - 10) * cos(angle) + cx;
  iy =  (r - 10) * sin(angle) + cy;
  // draw a triangle for the needle (compute and store 3 vertiticies)
  lx =  2 * cos(angle - 90 * degtorad) + cx;
  ly =  2 * sin(angle - 90 * degtorad) + cy;
  rx =  2 * cos(angle + 90 * degtorad) + cx;
  ry =  2 * sin(angle + 90 * degtorad) + cy;

  // blank out the old needle
  d.fillTriangle (pix, piy, plx, ply, prx, pry, SSD1306_BLACK);

  // then draw the new needle
  d.fillTriangle (ix, iy, lx, ly, rx, ry, SSD1306_WHITE);

  // draw a cute little dial center
  d.fillCircle(cx, cy, 3, SSD1306_WHITE);

  //save all current to old so the previous dial can be hidden
  pix = ix;
  piy = iy;
  plx = lx;
  ply = ly;
  prx = rx;
  pry = ry;
  // up until now print sends data to a video buffer NOT the screen
  // this call sends the data to the screen
  d.display();

}




